import express from 'express';
import http from 'http';
import { Server } from 'socket.io';
import mongoose from 'mongoose';
import cors from 'cors';
import dotenv from 'dotenv';
import { Transform } from 'json2csv';

import ReadingModel from './models/ReadingModel.js';
import authMiddleware from './middleware/authMiddleware.js';

dotenv.config();

const {
  PORT = 3000,
  MONGO_URI,
  RATE_PER_KWH = 6.5,
} = process.env;

const CARBON_EMISSION_FACTOR =
  Number(process.env.CARBON_EMISSION_FACTOR ?? 0.82);

if (!MONGO_URI) {
  throw new Error('Missing MONGO_URI in environment variables.');
}

const app = express();
const server = http.createServer(app);
const io = new Server(server, {
  cors: {
    origin: '*',
    methods: ['GET', 'POST'],
  },
});

app.use(cors());
app.use(express.json());

mongoose
  .connect(MONGO_URI, { autoIndex: true })
  .then(() => console.log('âœ… MongoDB connected'))
  .catch((err) => {
    console.error('âŒ MongoDB connection failed', err);
    process.exit(1);
  });

io.on('connection', (socket) => {
  console.log(`ðŸ”Œ Socket connected: ${socket.id}`);
  socket.on('disconnect', () =>
    console.log(`âš¡ Socket disconnected: ${socket.id}`),
  );
});

const clamp = (value, min, max) => Math.min(Math.max(value, min), max);

const parseDate = (value) => {
  if (!value) return null;
  const parsed = new Date(value);
  return Number.isNaN(parsed.getTime()) ? null : parsed;
};

const resolveQuickRange = (range = '30d') => {
  const now = new Date();
  const match = /^(\d+)([hdm])$/i.exec(range);
  if (!match) {
    return { start: new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000), end: now };
  }

  const amount = Number(match[1]);
  const unit = match[2].toLowerCase();
  const multiplier =
    unit === 'h'
      ? 60 * 60 * 1000
      : unit === 'd'
        ? 24 * 60 * 60 * 1000
        : 30 * 24 * 60 * 60 * 1000;

  return {
    start: new Date(now.getTime() - amount * multiplier),
    end: now,
  };
};

const buildMatchStage = ({ start, end, range }) => {
  const now = new Date();
  let startDate = parseDate(start);
  let endDate = parseDate(end) ?? now;

  if (!startDate) {
    const quick = resolveQuickRange(range);
    startDate = quick.start;
    endDate = quick.end;
  }

  return {
    timestamp: {
      $gte: startDate,
      $lte: endDate,
    },
  };
};

app.get('/api/health', (_, res) => {
  res.json({ status: 'ok', timestamp: new Date().toISOString() });
});

app.post('/api/webhook', authMiddleware, async (req, res, next) => {
  try {
    const { vrms, irms, power, energy, timestamp } = req.body ?? {};

    if ([vrms, irms, power, energy].some((value) => typeof value === 'undefined')) {
      return res.status(400).json({
        message: 'vrms, irms, power, and energy are required in the payload.',
      });
    }

    const numericVrms = Number(vrms);
    const numericIrms = Number(irms);
    const numericPower = Number(power);
    const numericEnergy = Number(energy);

    if (
      [numericVrms, numericIrms, numericPower, numericEnergy].some(
        (value) => Number.isNaN(value),
      )
    ) {
      return res.status(400).json({
        message: 'vrms, irms, power, and energy must be numeric values.',
      });
    }

    const previousReading = await ReadingModel.findOne({}, { energy: 1 })
      .sort({ timestamp: -1 })
      .lean();

    const previousEnergy = previousReading?.energy ?? 0;
    const deltaEnergy = Math.max(numericEnergy - previousEnergy, 0);

    const apparentPowerKva = Number(
      ((numericVrms * numericIrms) / 1000).toFixed(4),
    );
    const realPowerKw = Number((numericPower / 1000).toFixed(4));

    const powerFactor =
      apparentPowerKva === 0 ? 0 : clamp(realPowerKw / apparentPowerKva, 0, 1);
    const reactivePowerKvar = Number(
      Math.sqrt(
        Math.max(apparentPowerKva ** 2 - realPowerKw ** 2, 0),
      ).toFixed(4),
    );

    const instantCost = Number(
      (deltaEnergy * Number(RATE_PER_KWH)).toFixed(6),
    );

    const carbonFootprint = Number(
      (deltaEnergy * CARBON_EMISSION_FACTOR).toFixed(6),
    );

    const readingPayload = {
      vrms: numericVrms,
      irms: numericIrms,
      power: numericPower,
      energy: numericEnergy,
      real_power_kw: realPowerKw,
      apparent_power_kva: apparentPowerKva,
      power_factor: powerFactor,
      reactive_power_kvar: reactivePowerKvar,
      instant_cost: instantCost,
      carbon_footprint: carbonFootprint,
      timestamp: timestamp ? new Date(timestamp) : undefined,
    };

    const savedReading = await ReadingModel.create(readingPayload);
    const readingObject = savedReading.toObject();

    io.emit('live_data_update', readingObject);

    return res.status(201).json({
      message: 'Reading ingested successfully.',
      data: readingObject,
    });
  } catch (error) {
    return next(error);
  }
});

app.get('/api/export', async (req, res, next) => {
  try {
    const matchStage = buildMatchStage(req.query ?? {});
    const hasData = await ReadingModel.exists(matchStage);

    if (!hasData) {
      return res.status(404).json({
        message: 'No readings exist for the selected range.',
      });
    }

    const fields = [
      'timestamp',
      'vrms',
      'irms',
      'power',
      'energy',
      'real_power_kw',
      'apparent_power_kva',
      'reactive_power_kvar',
      'power_factor',
      'instant_cost',
      'carbon_footprint',
    ];

    const json2csv = new Transform({ fields }, { objectMode: true });
    const cursor = ReadingModel.find(matchStage).sort({ timestamp: 1 }).cursor();

    res.setHeader('Content-Type', 'text/csv');
    res.setHeader(
      'Content-Disposition',
      `attachment; filename="smart-meter-export-${Date.now()}.csv"`,
    );

    cursor.on('error', next);
    json2csv.on('error', next);

    cursor.pipe(json2csv).pipe(res);
  } catch (error) {
    next(error);
  }
});

app.get('/api/analysis/peaks', async (req, res, next) => {
  try {
    const matchStage = buildMatchStage(req.query ?? {});

    const aggregateByFormat = async (format) =>
      ReadingModel.aggregate([
        { $match: matchStage },
        {
          $group: {
            _id: {
              label: {
                $dateToString: { format, date: '$timestamp' },
              },
            },
            peak_power_kw: { $max: '$real_power_kw' },
            avg_power_kw: { $avg: '$real_power_kw' },
            peak_cost: { $max: '$instant_cost' },
            avg_cost: { $avg: '$instant_cost' },
          },
        },
        {
          $project: {
            _id: 0,
            label: '$_id.label',
            peak_power_kw: { $round: ['$peak_power_kw', 4] },
            avg_power_kw: { $round: ['$avg_power_kw', 4] },
            peak_cost: { $round: ['$peak_cost', 6] },
            avg_cost: { $round: ['$avg_cost', 6] },
          },
        },
        { $sort: { label: 1 } },
      ]);

    const [daily, monthly] = await Promise.all([
      aggregateByFormat('%Y-%m-%d'),
      aggregateByFormat('%Y-%m'),
    ]);

    res.json({ daily, monthly });
  } catch (error) {
    next(error);
  }
});

app.get('/api/analysis/trends', async (req, res, next) => {
  try {
    const { bucket = 'day' } = req.query ?? {};
    const format = bucket === 'month' ? '%Y-%m' : '%Y-%m-%d';
    const matchStage = buildMatchStage(req.query ?? {});

    const trends = await ReadingModel.aggregate([
      { $match: matchStage },
      {
        $group: {
          _id: {
            label: {
              $dateToString: { format, date: '$timestamp' },
            },
          },
          avg_power_kw: { $avg: '$real_power_kw' },
          total_cost: { $sum: '$instant_cost' },
          avg_power_factor: { $avg: '$power_factor' },
          total_carbon: { $sum: '$carbon_footprint' },
        },
      },
      {
        $project: {
          _id: 0,
          label: '$_id.label',
          avg_power_kw: { $round: ['$avg_power_kw', 4] },
          total_cost: { $round: ['$total_cost', 6] },
          avg_power_factor: { $round: ['$avg_power_factor', 4] },
          total_carbon: { $round: ['$total_carbon', 6] },
        },
      },
      { $sort: { label: 1 } },
    ]);

    res.json({ bucket, data: trends });
  } catch (error) {
    next(error);
  }
});

app.use((err, req, res, _next) => {
  console.error('Unhandled error:', err);
  res.status(err.status || 500).json({
    message: err.message || 'Internal server error',
  });
});

server.listen(PORT, () => {
  console.log(`ðŸš€ Server listening on http://localhost:${PORT}`);
});

